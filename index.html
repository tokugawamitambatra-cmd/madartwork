<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Media (img-1…img-Y)</title>
<link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Media&quot;,&quot;short_name&quot;:&quot;Media&quot;,&quot;start_url&quot;:&quot;./&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#000&quot;,&quot;theme_color&quot;:&quot;#000&quot;}" />
<style>
  :root{
    --bg:#000;--fg:#fff;--muted:#9aa3ad;
    --btnBg:rgba(0,0,0,.6);--btnRing:rgba(255,255,255,.22);
    --bar:#3b82f6;--barBg:rgba(255,255,255,.08)
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent}

  /* Full-viewport vertical slides with snap */
  .stack{height:100%;width:100%;overflow:auto;scroll-snap-type:y mandatory;scroll-behavior:smooth;background:#000}
  .slide{position:relative;min-height:100dvh;height:100dvh;display:grid;place-items:center;scroll-snap-align:start;scroll-snap-stop:always}

  /* Fit media to screen without cropping */
  .media{width:100vw;height:100dvh;max-width:100vw;max-height:100dvh;object-fit:contain;background:#000}
  video.media{background:#000}

  /* Audio layout */
  .audioWrap{display:grid;place-items:center;width:100%;height:100%;padding:16px}
  .audioPlayer{width:min(820px,92vw)}

  /* Per-slide tiny placeholder */
  .ph{position:absolute;inset:0;display:grid;place-items:center;color:#8a8a8a;font:14px system-ui}
  .hidden{visibility:hidden}

  /* === BIG NAV BUTTONS (don’t cover center) === */
  .navZones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;bottom:0;width:45%;pointer-events:auto}
  .left{left:0}
  .right{right:0}
  .bigBtn{
    position:absolute;top:50%;transform:translateY(-50%);
    width:88px;height:88px;border-radius:999px;border:2px solid var(--btnRing);
    display:grid;place-items:center;background:var(--btnBg);color:#fff;
    font-size:40px;line-height:1;text-decoration:none;user-select:none;cursor:pointer
  }
  .left .bigBtn{left:12px}
  .right .bigBtn{right:12px}
  .bigBtn:active{transform:translateY(-50%) scale(.98)}
  @media (min-width:768px){
    .bigBtn{width:104px;height:104px;font-size:48px;border-width:3px}
    .left .bigBtn{left:18px}
    .right .bigBtn{right:18px}
  }

  /* === GLOBAL DOWNLOAD BUTTON (big, centered) === */
  .dlGlobal{
    position:fixed;left:50%;bottom:14px;transform:translateX(-50%);
    z-index:10000;
    background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    color:#fff;text-decoration:none;border:1px solid var(--btnRing);
    border-radius:999px;padding:14px 22px;font-weight:800;font-size:16px;
    backdrop-filter:blur(8px);box-shadow:0 8px 26px rgba(0,0,0,.45);
  }
  .dlGlobal:active{transform:translateX(-50%) translateY(1px)}

  /* === LOADING OVERLAY (for first media) === */
  .loader{
    position:fixed;inset:0;display:grid;place-items:center;
    background:rgba(0,0,0,.65);backdrop-filter:blur(6px);
    z-index:10001;
  }
  .loader.off{display:none}
  .spinWrap{display:grid;place-items:center;gap:14px}
  .ring{
    width:88px;height:88px;border-radius:50%;
    background:
      conic-gradient(from 0deg, var(--bar) 0 270deg, rgba(255,255,255,.15) 270deg 360deg);
    -webkit-mask:radial-gradient(circle at 50% 50%, transparent 60%, #000 61%);
            mask:radial-gradient(circle at 50% 50%, transparent 60%, #000 61%);
    animation:spin 1s linear infinite;
  }
  @keyframes spin{to{transform:rotate(1turn)}}
  .loadText{font:600 14px/1.3 system-ui,Segoe UI,Roboto,Inter,Arial;color:#e5e7eb;text-align:center}
  .subText{font:12px system-ui;color:var(--muted)}

  /* === TOP PROGRESS BAR (visible during scanning after first item) === */
  .loadWrap{position:fixed;top:0;left:0;right:0;height:6px;background:var(--barBg);z-index:9999}
  .bar{position:absolute;left:0;top:0;height:100%;width:0;background:var(--bar);transition:width .25s ease}
  .indeterminate{background:
    linear-gradient(90deg,transparent,rgba(59,130,246,.9),transparent);
    background-size:200% 100%;animation:indet 1s linear infinite}
  @keyframes indet{0%{background-position:200% 0}100%{background-position:-200% 0}}
</style>
</head>
<body>
<!-- First-load overlay -->
<div id="loader" class="loader">
  <div class="spinWrap">
    <div class="ring" aria-hidden="true"></div>
    <div class="loadText">Scanning media…</div>
    <div class="subText">Looking for <code>img-1, img-2, …</code></div>
  </div>
</div>

<!-- Top progress bar (hidden after scan) -->
<div class="loadWrap" id="loadWrap" style="display:none"><div id="loadBar" class="bar indeterminate"></div></div>

<div id="stack" class="stack" aria-live="polite"></div>

<!-- Big navigation overlay -->
<div class="navZones" aria-hidden="false">
  <div class="zone left">
    <button id="btnPrev" class="bigBtn" aria-label="Previous" title="Previous (←)">&#x2039;</button>
  </div>
  <div class="zone right">
    <button id="btnNext" class="bigBtn" aria-label="Next" title="Next (→)">&#x203A;</button>
  </div>
</div>

<!-- Global, centered Download button -->
<a id="downloadBtn" class="dlGlobal" href="#" download aria-label="Download current file">Download</a>

<script>
/* ===== Config ===== */
const baseName = "img-"; // img-1, img-2, ...
const exts = {
  image:["jpg","jpeg","png","webp","gif","svg","avif"],
  video:["mp4","webm","ogv"],
  audio:["mp3","m4a","aac","wav","oga","ogg"]
};
const allExts=[...exts.image,...exts.video,...exts.audio];
const qs=new URLSearchParams(location.search);
const startIndex = Math.max(1, parseInt(qs.get("start")||"1",10));
const maxIndex   = Math.min(parseInt(qs.get("max")||"999",10) || 999, 5000);
const stopAtFirstMiss = (qs.get("gap")||"").toLowerCase()!=="allow"; // contiguous
const scanConcurrency = 6;

/* ===== Elements & state ===== */
const $stack = document.getElementById("stack");
const $btnPrev = document.getElementById("btnPrev");
const $btnNext = document.getElementById("btnNext");
const $dlGlobal = document.getElementById("downloadBtn");
const $loader = document.getElementById("loader");
const $barWrap = document.getElementById("loadWrap");
const $bar = document.getElementById("loadBar");

const observed = new WeakSet();
let slidesRef = [];
let firstVisibleSet = false;

/* ===== Networking helpers ===== */
async function headOrTinyGet(url){
  try{ const r = await fetch(url,{method:"HEAD",cache:"no-store"}); if (r.ok) return r; }catch{}
  try{ const r2= await fetch(url,{headers:{"Range":"bytes=0-0"},cache:"no-store"}); return r2; }catch{ return {ok:false}; }
}
async function findMediaFor(i){
  for (const ext of allExts){
    const url = `${baseName}${i}.${ext}`;
    const r = await headOrTinyGet(url);
    if (r.ok){
      const ct=(r.headers?.get?.("content-type")||"").toLowerCase();
      const t = ct.startsWith("image") ? "image"
             : ct.startsWith("video") ? "video"
             : ct.startsWith("audio") ? "audio"
             : (exts.image.includes(ext)?"image":exts.video.includes(ext)?"video":"audio");
      return {index:i,url,type:t,ext};
    }
  }
  return null;
}

/* ===== UI builders ===== */
function makeSlide(meta){
  const slide = document.createElement("section");
  slide.className = "slide";
  slide.dataset.url = meta.url;
  slide.dataset.type = meta.type;

  const ph = document.createElement("div");
  ph.className = "ph";
  ph.textContent = `Loading ${meta.url}…`;
  slide.appendChild(ph);

  return slide;
}
function mountMedia(slide){
  if (observed.has(slide)) return;
  observed.add(slide);
  const url = slide.dataset.url;
  const t   = slide.dataset.type;

  function firstVisual(){
    if (!firstVisibleSet){
      firstVisibleSet = true;
      // Hide big overlay, show top bar while scanning continues
      $loader.classList.add("off");
      $barWrap.style.display = "block";
      updateDownloadFor(slide);
    }
  }

  if (t === "image"){
    const img = document.createElement("img");
    img.className = "media hidden"; img.alt = url; img.decoding="async";
    img.addEventListener("load", ()=>{ img.classList.remove("hidden"); slide.querySelector(".ph")?.remove(); firstVisual(); }, {once:true});
    img.src = url; slide.appendChild(img);
  }else if (t === "video"){
    const vid = document.createElement("video");
    vid.className="media hidden"; vid.playsInline=true; vid.controls=true; vid.preload="metadata";
    vid.addEventListener("loadeddata", ()=>{ vid.classList.remove("hidden"); slide.querySelector(".ph")?.remove(); firstVisual(); }, {once:true});
    vid.src = url; slide.appendChild(vid);
  }else{
    const wrap = document.createElement("div"); wrap.className="audioWrap";
    const aud = document.createElement("audio"); aud.className="audioPlayer"; aud.controls=true; aud.preload="metadata"; aud.src=url;
    aud.addEventListener("loadeddata", ()=>{ slide.querySelector(".ph")?.remove(); firstVisual(); }, {once:true});
    wrap.appendChild(aud); slide.appendChild(wrap);
  }
}

/* Lazy mount */
const io = new IntersectionObserver((entries)=>{
  entries.forEach(e=>{ if(e.isIntersecting) { mountMedia(e.target); updateDownloadFor(e.target); } });
},{root:$stack, rootMargin:"200px 0px", threshold:0.01});

/* ===== Loading bar control ===== */
function setIndeterminate(on){
  if (on){ $bar.classList.add("indeterminate"); $bar.style.width="100%"; }
  else { $bar.classList.remove("indeterminate"); $bar.style.width="0%"; }
}
function setProgress(f){ // f in [0,1]
  $bar.classList.remove("indeterminate");
  $bar.style.width = (Math.max(0, Math.min(1, f))*100).toFixed(1)+"%";
}
function hideBar(){ $bar.style.width="0%"; $bar.classList.remove("indeterminate"); $barWrap.style.display="none"; }

/* ===== Download button control (global) ===== */
function currentSlideIndex(){
  let bestIdx = 0, bestDist = Infinity;
  slidesRef.forEach((el, i)=>{
    const r = el.getBoundingClientRect();
    const dist = Math.abs(r.top);
    if (dist < bestDist){ bestDist = dist; bestIdx = i; }
  });
  return bestIdx;
}
function currentSlide(){ return slidesRef[currentSlideIndex()] || null; }
function updateDownloadFor(slideEl){
  const s = slideEl || currentSlide();
  if (!s) return;
  const url = s.dataset.url;
  $dlGlobal.href = url;
  $dlGlobal.setAttribute("download", url.split("/").pop());
}

/* ===== Scan strategy ===== */
const scanConcurrency = 6; // (redeclared intentionally – keep here for clarity)
(async function boot(){
  setIndeterminate(true);

  // Find first hit
  let firstMeta = null;
  for (let i=startIndex; i<=maxIndex; i++){
    const m = await findMediaFor(i);
    if (m){ firstMeta = m; break; }
  }
  if (!firstMeta){
    $loader.querySelector(".loadText").textContent = "No media found";
    $loader.querySelector(".subText").textContent = "Place img-1, img-2, … next to this page.";
    setIndeterminate(false);
    return;
  }

  // Render first slide immediately
  const firstSlide = makeSlide(firstMeta);
  $stack.appendChild(firstSlide);
  slidesRef.push(firstSlide);
  io.observe(firstSlide);
  mountMedia(firstSlide); // triggers overlay hide when loaded

  // Continue scanning forward with small concurrency
  let stop = false;
  let lastGood = firstMeta.index;
  let knownTotal = null;
  let discovered = 1;

  async function scanIndex(i){
    if (stop) return;
    const m = await findMediaFor(i);
    if (m){
      lastGood = i;
      discovered++;
      const s = makeSlide(m);
      $stack.appendChild(s);
      slidesRef.push(s);
      io.observe(s);
      // Prefetch hint for the next one
      const l = document.createElement("link"); l.rel="prefetch"; l.href=m.url; document.head.appendChild(l);
    }else if (stopAtFirstMiss){
      stop = true;
      knownTotal = lastGood - firstMeta.index + 1;
      setProgress(discovered / knownTotal);
      hideBar();
      return;
    }
    if (knownTotal){
      setProgress(discovered / knownTotal);
      if (discovered >= knownTotal) hideBar();
    }
  }

  // Switch from full overlay to bar as soon as first media is up; already handled in mountMedia()

  // Start workers
  let cursor = firstMeta.index + 1;
  const workers = Array.from({length: scanConcurrency}, async ()=>{
    while(!stop && cursor <= maxIndex){
      const i = cursor++;
      await scanIndex(i);
    }
  });
  await Promise.all(workers);

  if (!knownTotal){ // reached max without a miss
    setIndeterminate(false);
    hideBar();
  }

  // Deep-link
  const h = parseInt(location.hash.replace("#",""),10);
  if (!isNaN(h) && h>=1 && h<=slidesRef.length){ slidesRef[h-1].scrollIntoView({block:"start"}); }
})();

/* ===== Nav buttons ===== */
function goto(idx){
  if (!slidesRef.length) return;
  const clamped = Math.max(0, Math.min(idx, slidesRef.length-1));
  slidesRef[clamped].scrollIntoView({block:"start", behavior:"smooth"});
  location.hash = String(clamped+1);
  updateDownloadFor(slidesRef[clamped]);
}
document.getElementById("btnPrev").addEventListener("click", ()=> goto(currentSlideIndex()-1));
document.getElementById("btnNext").addEventListener("click", ()=> goto(currentSlideIndex()+1));

addEventListener("keydown", (e)=>{
  if (e.key==="ArrowLeft") goto(currentSlideIndex()-1);
  if (e.key==="ArrowRight") goto(currentSlideIndex()+1);
});

/* Update download target on scroll end */
let scrollTO=null;
$stack.addEventListener("scroll", ()=>{
  clearTimeout(scrollTO);
  scrollTO = setTimeout(()=> updateDownloadFor(), 120);
},{passive:true});

/* Swipe (horizontal) */
let x0=null,y0=null;
addEventListener("touchstart",e=>{ const t=e.touches[0]; x0=t.clientX; y0=t.clientY; },{passive:true});
addEventListener("touchend",e=>{
  if (x0===null) return;
  const t=e.changedTouches[0]; const dx=t.clientX-x0; const dy=t.clientY-y0;
  if (Math.abs(dx)>50 && Math.abs(dx)>Math.abs(dy)){ dx<0 ? goto(currentSlideIndex()+1) : goto(currentSlideIndex()-1); }
  x0=y0=null;
},{passive:true});

/* Service worker */
if ("serviceWorker" in navigator){
  navigator.serviceWorker.register("./sw.js").catch(()=>{});
}
</script>
</body>
</html>
