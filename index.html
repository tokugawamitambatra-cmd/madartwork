<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Media (img-1…img-Y)</title>
<link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;Media&quot;,&quot;short_name&quot;:&quot;Media&quot;,&quot;start_url&quot;:&quot;./&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#000&quot;,&quot;theme_color&quot;:&quot;#000&quot;}" />
<style>
  :root{--bg:#000;--fg:#fff;--dim:rgba(0,0,0,.45);--btnBg:rgba(0,0,0,.55);--btnRing:rgba(255,255,255,.18);--bar:#3b82f6}
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);-webkit-tap-highlight-color:transparent}

  /* Vertical full-viewport stack with snap */
  .stack{height:100%;width:100%;overflow:auto;scroll-snap-type:y mandatory;scroll-behavior:smooth;background:#000}
  .slide{position:relative;min-height:100dvh;height:100dvh;display:grid;place-items:center;scroll-snap-align:start;scroll-snap-stop:always}

  /* Fit media to screen without cropping */
  .media{width:100vw;height:100dvh;max-width:100vw;max-height:100dvh;object-fit:contain;background:#000}
  video.media{background:#000}

  /* Audio */
  .audioWrap{display:grid;place-items:center;width:100%;height:100%;padding:16px}
  .audioPlayer{width:min(820px,92vw)}

  /* Download */
  .dl{position:absolute;right:10px;bottom:10px;border:0;border-radius:999px;background:var(--dim);
      padding:10px 14px;color:#fff;font-weight:700;text-decoration:none;font-size:14px;backdrop-filter:blur(6px)}
  .dl:active{transform:translateY(1px)}

  /* Placeholder */
  .ph{position:absolute;inset:0;display:grid;place-items:center;color:#8a8a8a;font:14px system-ui}
  .hidden{visibility:hidden}

  /* === BIG NAV BUTTONS === */
  .navZones{position:fixed;inset:0;pointer-events:none}
  .zone{position:absolute;top:0;bottom:0;width:50%;pointer-events:auto}
  .left{left:0}
  .right{right:0}
  .bigBtn{
    position:absolute;top:50%;transform:translateY(-50%);
    width:88px;height:88px;border-radius:999px;border:2px solid var(--btnRing);
    display:grid;place-items:center;background:var(--btnBg);color:#fff;
    font-size:40px;line-height:1;text-decoration:none;user-select:none;cursor:pointer
  }
  .left .bigBtn{left:12px}
  .right .bigBtn{right:12px}
  .bigBtn:active{transform:translateY(-50%) scale(.98)}
  @media (min-width:768px){
    .bigBtn{width:104px;height:104px;font-size:48px;border-width:3px}
    .left .bigBtn{left:18px}
    .right .bigBtn{right:18px}
  }

  /* === LOADING BAR === */
  .loadWrap{position:fixed;top:0;left:0;right:0;height:3px;background:transparent;z-index:9999}
  .bar{position:absolute;left:0;top:0;height:100%;width:0;background:var(--bar);transition:width .25s ease}
  .indeterminate{background:linear-gradient(90deg,transparent,rgba(59,130,246,.7),transparent);
    background-size:200% 100%;animation:indet 1s linear infinite}
  @keyframes indet{0%{background-position:200% 0}100%{background-position:-200% 0}}
</style>
</head>
<body>
<div class="loadWrap"><div id="loadBar" class="bar indeterminate"></div></div>

<div id="stack" class="stack" aria-live="polite"></div>

<!-- Big navigation overlay -->
<div class="navZones" aria-hidden="false">
  <div class="zone left">
    <button id="btnPrev" class="bigBtn" aria-label="Previous" title="Previous (←)">&#x2039;</button>
  </div>
  <div class="zone right">
    <button id="btnNext" class="bigBtn" aria-label="Next" title="Next (→)">&#x203A;</button>
  </div>
</div>

<script>
/* ===== Config ===== */
const baseName = "img-"; // img-1, img-2, ...
const exts = {
  image:["jpg","jpeg","png","webp","gif","svg","avif"],
  video:["mp4","webm","ogv"],
  audio:["mp3","m4a","aac","wav","oga","ogg"]
};
const allExts=[...exts.image,...exts.video,...exts.audio];
const qs=new URLSearchParams(location.search);
const startIndex = Math.max(1, parseInt(qs.get("start")||"1",10));
const maxIndex   = Math.min(parseInt(qs.get("max")||"999",10) || 999, 5000);
const stopAtFirstMiss = (qs.get("gap")||"").toLowerCase()!=="allow"; // contiguous
const scanConcurrency = 6; // speed up discovery without hammering

/* ===== Elements & state ===== */
const $stack = document.getElementById("stack");
const $btnPrev = document.getElementById("btnPrev");
const $btnNext = document.getElementById("btnNext");
const $bar = document.getElementById("loadBar");
const observed = new WeakSet();
let slidesRef = [];

/* ===== Networking helpers ===== */
async function headOrTinyGet(url){
  try{ const r = await fetch(url,{method:"HEAD",cache:"no-store"}); if (r.ok) return r; }catch{}
  try{ const r2= await fetch(url,{headers:{"Range":"bytes=0-0"},cache:"no-store"}); return r2; }catch{ return {ok:false}; }
}
async function findMediaFor(i){
  for (const ext of allExts){
    const url = `${baseName}${i}.${ext}`;
    const r = await headOrTinyGet(url);
    if (r.ok){
      const ct=(r.headers?.get?.("content-type")||"").toLowerCase();
      const t = ct.startsWith("image") ? "image"
             : ct.startsWith("video") ? "video"
             : ct.startsWith("audio") ? "audio"
             : (exts.image.includes(ext)?"image":exts.video.includes(ext)?"video":"audio");
      return {index:i,url,type:t,ext};
    }
  }
  return null;
}

/* ===== UI builders ===== */
function makeSlide(meta){
  const slide = document.createElement("section");
  slide.className = "slide";
  slide.dataset.url = meta.url;
  slide.dataset.type = meta.type;

  const ph = document.createElement("div");
  ph.className = "ph";
  ph.textContent = `Loading ${meta.url}…`;
  slide.appendChild(ph);

  const dl = document.createElement("a");
  dl.className = "dl";
  dl.href = meta.url;
  dl.setAttribute("download", meta.url.split("/").pop());
  dl.textContent = "Download";
  slide.appendChild(dl);

  return slide;
}
function mountMedia(slide){
  if (observed.has(slide)) return;
  observed.add(slide);
  const url = slide.dataset.url;
  const t   = slide.dataset.type;

  if (t === "image"){
    const img = document.createElement("img");
    img.className = "media hidden"; img.alt = url; img.decoding="async";
    img.addEventListener("load", ()=>{ img.classList.remove("hidden"); slide.querySelector(".ph")?.remove(); }, {once:true});
    img.src = url; slide.appendChild(img);
  }else if (t === "video"){
    const vid = document.createElement("video");
    vid.className="media hidden"; vid.playsInline=true; vid.controls=true; vid.preload="metadata";
    vid.addEventListener("loadeddata", ()=>{ vid.classList.remove("hidden"); slide.querySelector(".ph")?.remove(); }, {once:true});
    vid.src = url; slide.appendChild(vid);
  }else{
    const wrap = document.createElement("div"); wrap.className="audioWrap";
    const aud = document.createElement("audio"); aud.className="audioPlayer"; aud.controls=true; aud.preload="metadata"; aud.src=url;
    wrap.appendChild(aud); slide.appendChild(wrap); slide.querySelector(".ph")?.remove();
  }
}

/* Lazy mount */
const io = new IntersectionObserver((entries)=>{
  entries.forEach(e=>{ if(e.isIntersecting) mountMedia(e.target); });
},{root:$stack, rootMargin:"200px 0px", threshold:0.01});

/* ===== Loading bar control ===== */
function setIndeterminate(on){
  if (on){ $bar.classList.add("indeterminate"); $bar.style.width="100%"; }
  else { $bar.classList.remove("indeterminate"); $bar.style.width="0%"; }
}
function setProgress(f){ // f in [0,1]
  $bar.classList.remove("indeterminate");
  $bar.style.width = (Math.max(0, Math.min(1, f))*100).toFixed(1)+"%";
}
function hideBar(){ $bar.style.width="0%"; $bar.classList.remove("indeterminate"); $bar.parentElement.style.display="none"; }

/* ===== Scan strategy =====
   1) Quickly find the FIRST existing index (sequentially) and show it immediately.
   2) Continue scanning forward with small concurrency until first miss (contiguous), building slides.
   3) While scanning, update loading bar (indeterminate -> determinate once we know total).
*/
(async function boot(){
  setIndeterminate(true);

  // 1) Find first hit
  let firstMeta = null;
  for (let i=startIndex; i<=maxIndex; i++){
    const m = await findMediaFor(i);
    if (m){ firstMeta = m; break; }
  }
  if (!firstMeta){
    // nothing found
    setIndeterminate(false);
    hideBar();
    const empty=document.createElement("div");
    empty.style.cssText="display:grid;place-items:center;height:100dvh;color:#bbb;font:16px system-ui;text-align:center;padding:24px";
    empty.textContent="No media found. Place files named img-1, img-2, … (contiguous) with supported extensions next to this page.";
    $stack.appendChild(empty);
    return;
  }

  // Show the first slide immediately
  const firstSlide = makeSlide(firstMeta);
  $stack.appendChild(firstSlide);
  slidesRef.push(firstSlide);
  io.observe(firstSlide);
  // Ensure it's mounted right away for instant visual
  mountMedia(firstSlide);

  // 2) Continue scanning forward with limited concurrency
  let stop = false;
  let lastGood = firstMeta.index;
  let knownTotal = null; // when we hit first miss
  let discovered = 1;

  async function scanIndex(i){
    if (stop) return;
    const m = await findMediaFor(i);
    if (m){
      lastGood = i;
      discovered++;
      const s = makeSlide(m);
      $stack.appendChild(s);
      slidesRef.push(s);
      io.observe(s);
    }else if (stopAtFirstMiss){
      // We hit the first gap -> we know total count now
      stop = true;
      knownTotal = lastGood - firstMeta.index + 1;
      setProgress(discovered / knownTotal);
      hideBar(); // done
      return;
    }
    if (knownTotal){
      setProgress(discovered / knownTotal);
      if (discovered >= knownTotal) hideBar();
    }
  }

  // Kick off workers
  let cursor = firstMeta.index + 1;
  const workers = Array.from({length: scanConcurrency}, async ()=>{
    while(!stop && cursor <= maxIndex){
      const i = cursor++; // claim next
      await scanIndex(i);
      if (!stop && !knownTotal && stopAtFirstMiss){
        // If we found a miss, scanIndex will set stop & knownTotal and hide bar
      }
    }
  });
  await Promise.all(workers);

  // If sequence reached maxIndex and we never saw a miss (rare), switch bar off
  if (!knownTotal){
    setIndeterminate(false);
    hideBar();
  }

  // Optional deep-link to #N (1-based)
  const h = parseInt(location.hash.replace("#",""),10);
  if (!isNaN(h) && h>=1 && h<=slidesRef.length){ slidesRef[h-1].scrollIntoView({block:"start"}); }
})();

/* ===== BIG NAV BUTTONS ===== */
function currentSlideIndex(){
  let bestIdx = 0, bestDist = Infinity;
  slidesRef.forEach((el, i)=>{
    const r = el.getBoundingClientRect();
    const dist = Math.abs(r.top);
    if (dist < bestDist){ bestDist = dist; bestIdx = i; }
  });
  return bestIdx;
}
function goto(idx){
  if (!slidesRef.length) return;
  const clamped = Math.max(0, Math.min(idx, slidesRef.length-1));
  slidesRef[clamped].scrollIntoView({block:"start", behavior:"smooth"});
  location.hash = String(clamped+1);
}
document.getElementById("btnPrev").addEventListener("click", ()=> goto(currentSlideIndex()-1));
document.getElementById("btnNext").addEventListener("click", ()=> goto(currentSlideIndex()+1));

addEventListener("keydown", (e)=>{
  if (e.key==="ArrowLeft") goto(currentSlideIndex()-1);
  if (e.key==="ArrowRight") goto(currentSlideIndex()+1);
});

/* Horizontal swipe for next/prev */
let x0=null,y0=null;
addEventListener("touchstart",e=>{ const t=e.touches[0]; x0=t.clientX; y0=t.clientY; },{passive:true});
addEventListener("touchend",e=>{
  if (x0===null) return;
  const t=e.changedTouches[0]; const dx=t.clientX-x0; const dy=t.clientY-y0;
  if (Math.abs(dx)>50 && Math.abs(dx)>Math.abs(dy)){ dx<0 ? goto(currentSlideIndex()+1) : goto(currentSlideIndex()-1); }
  x0=y0=null;
},{passive:true});

/* Service worker (same folder) */
if ("serviceWorker" in navigator){
  navigator.serviceWorker.register("./sw.js").catch(()=>{});
}
</script>
</body>
</html>
